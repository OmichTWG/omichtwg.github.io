"use strict";function __Vector(e,t){this.x=e,this.y=t}function __Polygon(e,t){this.vertex=e,this.edge=t}const __getEdgesByVertices=e=>{const t=[],o=(t,o)=>new __Vector(e[o].x-e[t].x,e[o].y-e[t].y);for(let l=0;l<e.length-1;l++)t.push(o(l,l+1));return t.push(o(e.length-1,0)),t},__getRotatedPoint=(e,t,o,l,r)=>{const n=r*Math.PI/180,_=o-e,i=l-t,y=Math.sqrt(_*_+i*i),c=Math.atan2(i,_);return new __Vector(e+y*Math.cos(c+n),t+y*Math.sin(c+n))},__checkPolygonPolygon=(e,t)=>{let o=null,l=0;const r=[];let n=null,_=null,i=null,y=null;for(let t=0;t<e.edge.length;t++)o=new __Vector(-e.edge[t].y,e.edge[t].x),r.push(o);for(let e=0;e<t.edge.length;e++)o=new __Vector(-t.edge[e].y,t.edge[e].x),r.push(o);for(let o=0;o<r.length;o++){n=null,_=null,i=null,y=null;for(let t=0;t<e.vertex.length;t++)l=e.vertex[t].x*r[o].x+e.vertex[t].y*r[o].y,(null===_||l>_)&&(_=l),(null===n||l<n)&&(n=l);for(let e=0;e<t.vertex.length;e++)l=t.vertex[e].x*r[o].x+t.vertex[e].y*r[o].y,(null===y||l>y)&&(y=l),(null===i||l<i)&&(i=l);if(!(n<y&&n>i||i<_&&i>n))return!1}return!0},__getOffsetedBoxCollider=e=>({x1:e.collider.x1+e.x,x2:e.collider.x2+e.x,y1:e.collider.y1+e.y,y2:e.collider.y2+e.y,rotation:e.collider.rotation??0}),__getRotatedSquareCoordinates=e=>{const t=e.x1+(e.x2-e.x1)/2,o=e.y1+(e.y2-e.y1)/2;return{tl:__getRotatedPoint(t,o,e.x1,e.y1,e.rotation),tr:__getRotatedPoint(t,o,e.x2,e.y1,e.rotation),bl:__getRotatedPoint(t,o,e.x1,e.y2,e.rotation),br:__getRotatedPoint(t,o,e.x2,e.y2,e.rotation)}},__getBoxPolygon=e=>{const t=__getRotatedSquareCoordinates(__getOffsetedBoxCollider(e));return new __Polygon([new __Vector(t.tr.x,t.tr.y),new __Vector(t.br.x,t.br.y),new __Vector(t.bl.x,t.bl.y),new __Vector(t.tl.x,t.tl.y)],[new __Vector(t.br.x-t.tr.x,t.br.y-t.tr.y),new __Vector(t.bl.x-t.br.x,t.bl.y-t.br.y),new __Vector(t.tl.x-t.bl.x,t.tl.y-t.bl.y),new __Vector(t.tr.x-t.tl.x,t.tr.y-t.tl.y)])},__getEllipsePolygon=e=>{const{collider:t,x:o,y:l}=e,r=2*Math.PI,n=r/(t.edges||8),_=[];for(let e=0;e<r;e+=n){const r=o+(t.x||0),n=l+(t.y||0);_.push(__getRotatedPoint(r,n,r+Math.cos(e)*t.rw,n+Math.sin(e)*t.rh,t.rotation))}return new __Polygon(_,__getEdgesByVertices(_))},__getDotPolygon=(e,t)=>new __Polygon([new __Vector(e,t)],[]),__getPolygonPolygon=e=>{const{collider:t,x:o,y:l}=e,r=t.vertices.map((e=>new __Vector(o+e[0],l+e[1])));return new __Polygon(r,__getEdgesByVertices(r))},__getColliderPolygon=e=>{switch(e.collider.type){case"box":return __getBoxPolygon(e);case"ellipse":return __getEllipsePolygon(e);case"point":return __getDotPolygon(e.x+(e.collider.x||0),e.y+(e.collider.y||0));case"polygon":return __getPolygonPolygon(e)}},__checkBoxBox=(e,t)=>{const o=Math.min(e.x+e.collider.x2,t.x+t.collider.x2)-Math.max(e.x+e.collider.x1,t.x+t.collider.x1),l=Math.min(e.y+e.collider.y2,t.y+t.collider.y2)-Math.max(e.y+e.collider.y1,t.y+t.collider.y1);return!(o<=0||l<=0)},__checkCollision=(e,t)=>{if("box"!==e.collider.type||"box"!==t.collider.type||e.collider.rotation||t.collider.rotation){if(!__getColliderPolygon(e))return!1;return!!__getColliderPolygon(t)&&__checkPolygonPolygon(__getColliderPolygon(e),__getColliderPolygon(t))}return __checkBoxBox(e,t)},collisionCollider=(e,t,o,l)=>{const r=__getObjectsByFilter(e);for(let e of r)if(e.collider&&__checkCollision(e,{x:t,y:o,collider:l}))return e},collisionPoint=(e,t,o)=>{const l=__getObjectsByFilter(e);for(let e of l)if(e.collider&&__checkPolygonPolygon(__getColliderPolygon(e),__getDotPolygon(t,o)))return e};