"use strict";const __objects=[];let __instances=[],__objId=0,__instanceId=0;const __getObjectsByFilter=e=>"string"==typeof e?[...__instances.filter((t=>t.name===e)),...__instances.filter((t=>t.parent===e))]:__instances.filter(e),__inheritance=e=>{const t={...e};if(e.collider&&(t.collider={...e.collider}),t.parent)if(t.parent!==t.name){const e=__objects.find((e=>e.name===t.parent));e?Object.setPrototypeOf(t,__inheritance(e)):console.warn(`Нет объекта с именем ${t.parent}`)}else console.error("Нельзя наследовать объект от этого же объекта.");return t},__instanceCreateObj=e=>{const t=__inheritance({...e,id:__instanceId});__instanceId++,t.create&&t.create();let n=__instances.findIndex((e=>t.depth>=e.depth));return-1===n&&(n=__instances.length),__instances=__instances.slice(0,n).concat(t).concat(__instances.slice(n,__instances.length)),t},instanceCreate=(e,t,n,i,o={})=>{const s=__objects.find((t=>t.name===e));return s?__instanceCreateObj({...s,x:t,y:n,depth:i||s.depth,properties:o}):(console.error(`Нет объекта с именем "${e}"`),null)},instanceDestroy=e=>{e.onDestroy&&e.onDestroy(),__instances=__instances.filter((t=>t.id!==e.id))},findNearest=(e,t=0,n=0)=>{const i=__getObjectsByFilter(e);let o,s=1/0;for(let e of i){const i=distanceBetween(t,n,e.x,e.y);i<s&&(s=i,o=e)}return o},addObject=e=>{void 0===e.x&&(e.x=0),void 0===e.y&&(e.y=0),void 0===e.tpX&&(e.tpX=0),void 0===e.tpY&&(e.tpY=0),void 0===e.scaleX&&(e.scaleX=1),void 0===e.scaleY&&(e.scaleY=1),void 0===e.rotation&&(e.rotation=0),void 0===e.opacity&&(e.opacity=1),void 0===e.depth&&(e.depth=0),void 0===e.frameNumber&&(e.frameNumber=0),void 0===e.animationSpeed&&(e.animationSpeed=1),void 0===e.xPrevious&&(e.xPrevious=null),void 0===e.yPrevious&&(e.yPrevious=null),void 0===e.sprite&&(e.sprite=null),void 0===e.collide&&(e.collide=[]),void 0===e.properties&&(e.properties={}),e.objId=__objId,__objId++,__objects.push(e)},moveToPoint=(e,t,n,i)=>{if(distanceBetween(e.x,e.y,t,n)>i){const o=getDirectionVector(e.x,e.y,t,n);e.x+=o.x*i,e.y+=o.y*i}else e.x=t,e.y=n};